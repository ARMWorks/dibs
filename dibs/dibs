#!/bin/bash

if [[ -z "$DIBS_ROOT" ]] ; then
	echo "DIBS_ROOT is not set."
	exit 1
fi

if [[ $(id -u) -ne 0 ]] ; then
	echo "This script should be ran as root."
	exit 1
fi

if [[ "$DIBS_ROOT" = "$PWD" ]] ; then
	echo "Cannot work in DIBS root. Please create a directory to use as a DIBS_WORKSPACE."
	exit 1
fi

source "$DIBS_ROOT/dibs/platform"
source "$DIBS_ROOT/dibs/packages"
source "$DIBS_ROOT/dibs/system"
source "$DIBS_ROOT/dibs/network"
source "$DIBS_ROOT/dibs/image"
if [[ -f "$DIBS_WORKSPACE/board/config" ]] ; then
	source "$DIBS_WORKSPACE/board/config"
fi

function require_workspace()
{
	if [[ -z "$DIBS_WORKSPACE" ]] || [[ ! -f "$DIBS_WORKSPACE/.dibs_workspace" ]]; then
		echo "DIBS workspace not found. Try creating a directory and run \"dibs board\"."
		exit 1
	fi

	export KCONFIG_CONFIG="$DIBS_WORKSPACE/config/config"
}

function require_config()
{
	require_workspace

	if [[ ! -f "$KCONFIG_CONFIG" ]] ; then
		echo "Config not found. Try \"dibs config\"."
		exit 1
	fi

	source "$KCONFIG_CONFIG"

	platform_config
	packages_config
	system_config
	network_config
	image_config
	declare -fF board_config > /dev/null && board_config
}

function require_rootfs_tar()
{
	require_workspace

	if [[ ! -f "$DIBS_WORKSPACE/rootfs.tar" ]] ; then
		echo "rootfs.tar not found!  Have you ran \"dibs build\" yet?"
		exit 1
	fi
}

function require_target_dir()
{
	require_workspace

	export DIBS_TARGET="$DIBS_WORKSPACE/target"

	if [[ ! -d "$DIBS_TARGET" ]] ; then
		echo "No target filesystem found. Did you run \"dibs untar\"?"
		exit 1
	fi
}

# assumes require_config has already been ran
function install_static_qemu()
{
	if [[ -z "$DIBS_TARGET" ]] || [[ "$DIBS_TARGET" = "/" ]] ; then
		echo "install_static_qemu function cowardly refusing to run."
		exit 1
	fi

	local host=$(uname -m)

	if [[ ( $CONFIG_ARCH = armel || $CONFIG_ARCH = armhf ) && $host != arm* ]] ; then
		cp /usr/bin/qemu-arm-static "$DIBS_TARGET/usr/bin"
	elif [[ $CONFIG_ARCH = arm64 && ( $host != aarch64 ) ]] ; then
		cp /usr/bin/qemu-aarch64-static "$DIBS_TARGET/usr/bin"
	elif [[ $CONFIG_ARCH = i386 && ( $host != i686 && $host != x86_64 ) ]] ; then
		cp /usr/bin/qemu-i386-static "$DIBS_TARGET/usr/bin"
	elif [[ $CONFIG_ARCH = amd64 && $host != x86_64 ]] ; then
		cp /usr/bin/qemu-x86_64-static "$DIBS_TARGET/usr/bin"
	fi
}

# assumes require_config has already been ran
function uninstall_static_qemu()
{
	if [[ -z "$DIBS_TARGET" ]] || [[ "$DIBS_TARGET" = "/" ]] ; then
		echo "uninstall_static_qemu function cowardly refusing to run."
		exit 1
	fi

	local host=$(uname -m)

	if [[ ( $CONFIG_ARCH = armel || $CONFIG_ARCH = armhf ) && $host != arm* ]] ; then
		rm -f "$DIBS_TARGET/usr/bin/qemu-arm-static"
	elif [[ $CONFIG_ARCH = arm64 && ( $host != aarch64 ) ]] ; then
		rm -f "$DIBS_TARGET/usr/bin/qemu-aarch64-static"
	elif [[ $CONFIG_ARCH = i386 && ( $host != i686 && $host != x86_64 ) ]] ; then
		rm -f "$DIBS_TARGET/usr/bin/qemu-i386-static"
	elif [[ $CONFIG_ARCH = amd64 && $host != x86_64 ]] ; then
		rm -f "$DIBS_TARGET/usr/bin/qemu-x86_64-static"
	fi
}

function unmount_target_subdirs()
{
	IFS=$'\n'
	for line in $(mount) ; do
		local mountpoint="$(echo $line | cut -d' ' -f3)"
		if [ "${mountpoint##$DIBS_TARGET/}" != "${mountpoint}" ] ; then
			umount -R "$mountpoint"
		fi
	done
	unset IFS
}

dibs_build_help="build: dibs build
    Runs multistrap and stage2 chroot processes."
function dibs_build()
{
	require_config

	pushd "$DIBS_WORKSPACE" > /dev/null
	export DIBS_TARGET="$DIBS_WORKSPACE/target"
	mkdir -p "$DIBS_TARGET"
	multistrap -f "$DIBS_WORKSPACE/config/multistrap.conf" || (rm -r "$DIBS_TARGET" && exit 1)
	cd "$DIBS_TARGET"
	install_static_qemu
	chroot "$DIBS_TARGET" /stage2.sh
	network_postinstall
	system_postinstall
	declare -fF board_postinstall > /dev/null && board_postinstall
	uninstall_static_qemu
	dibs_tar
	popd > /dev/null
}

dibs_board_help="board: dibs board [name]
    Initializes a workspace with a given board name."
function dibs_board()
{
	local board=${1:-generic}

	if [[ ! -d "$DIBS_ROOT/boards/$board" ]] ; then
		echo "Board \"$board\" does not exist, aborting."
		return
	fi

	DIBS_WORKSPACE="$PWD"

	echo "board=$board" > .dibs_workspace

	f="$DIBS_WORKSPACE/Makefile"
	echo ".PHONY: all help
all: $DIBS_WORKSPACE/rootfs.tar
$DIBS_WORKSPACE/rootfs.tar: $DIBS_WORKSPACE/config/config
	@dibs build
help:
	@echo \"This is a convenience Makefile. Please see \\\"dibs help\\\" for more info.\"" > "$f"

	mkdir -p "$DIBS_WORKSPACE/board" "$DIBS_WORKSPACE/config"
	shopt -s dotglob
	cp -r "$DIBS_ROOT/boards/$board/"* "$DIBS_WORKSPACE/board"
	shopt -u dotglob

	if [[ -f "$DIBS_WORKSPACE/board/config" ]] && [[ ! -f "$DIBS_WORKSPACE/config/config" ]] ; then
		cp "$DIBS_WORKSPACE/board/config" "$DIBS_WORKSPACE/config/config"
	fi

	ln -sf "$DIBS_ROOT/dibs" "$DIBS_WORKSPACE"
}

dibs_config_help="config: dibs config
    Pre-build configuration. First runs kconfig-mconfig and then
    generates output files."
function dibs_config()
{
	require_workspace

	packages_generate
	declare -fF board_generate > /dev/null && board_generate
	pushd "$DIBS_WORKSPACE" > /dev/null
	kconfig-mconf "dibs/Kconfig"
	popd > /dev/null

	if [[ -f "$DIBS_WORKSPACE/config/config" ]] ; then
		dibs_regen
	fi
}

function dibs_help()
{
	var=dibs_${1}_help
	declare -p $var > /dev/null 2>&1 && echo "${!var}" || dibs_usage
	exit 1
}

dibs_image_help="image: dibs image
	Builds an image from rootfs.tar."
function dibs_image()
{
	require_config
	require_rootfs_tar

	# determine partition numbers, offsets and sizes, and the image size
	local offset=64
	if [[ "y" = "$bootloader_at_start" ]] ; then
		offset=$(expr $offset + 8128) # 4 MB
	fi

	local part=1
	local boot_part=0
	if [[ "y" = "$CONFIG_IMAGE_PARTITION_BOOT" ]] ; then
		boot_part=$part
		local boot_start=$offset
		boot_size=$(expr $CONFIG_IMAGE_PARTITION_BOOT_SIZE \* 2048)
		offset=$(expr $offset + $boot_size)
		part=$(expr $part + 1)
	fi

	local swap_part=0
	if [[ "y" = "$CONFIG_IMAGE_PARTITION_SWAP_EMBED" ]] ; then
		swap_part=$part
		local swap_start=$offset
		swap_size=$(expr $CONFIG_IMAGE_PARTITION_SWAP_SIZE \* 2048)
		offset=$(expr $offset + $swap_size)
		part=$(expr $part + 1)
	fi

	local root_part=$part
	local root_start=$offset
	local tarball_size=$(du -0 -b "$DIBS_WORKSPACE/rootfs.tar" | cut -f1)
	local root_size=$(expr \( $tarball_size \* 12 / 10 + 511 \) / 512)
	offset=$(expr $offset + $root_size)

	local image_size=$offset

	# create sparse image
	truncate -s 0 $DIBS_WORKSPACE/image.bin
	dd of="$DIBS_WORKSPACE/image.bin" bs=512 count=0 seek=$image_size 2> /dev/null

	# make partition table
	echo "label: dos" > "$DIBS_WORKSPACE/config/sfdisk.conf"

	if [[ $boot_part -gt 0 ]] ; then
		if [[ "fat32" = "$CONFIG_IMAGE_PARTITION_BOOT_TYPE" ]] ; then
			echo "$boot_start,$boot_size,c" >> "$DIBS_WORKSPACE/config/sfdisk.conf"
		else
			echo "$boot_start,$boot_size,L" >> "$DIBS_WORKSPACE/config/sfdisk.conf"
		fi
	fi

	if [[ $swap_part -gt 0 ]] ; then
		echo "$swap_start,$swap_size,S" >> "$DIBS_WORKSPACE/config/sfdisk.conf"
	fi

	echo "$root_start,$root_size,L" >> "$DIBS_WORKSPACE/config/sfdisk.conf"

	cat "$DIBS_WORKSPACE/config/sfdisk.conf" | sfdisk "$DIBS_WORKSPACE/image.bin" > /dev/null

	# create loop device(s)
	local loop=$(losetup -f)
	losetup -P $loop "$DIBS_WORKSPACE/image.bin"

	# make filesystem(s)
	if [[ $boot_size -gt 0 ]] ; then
		if [[ "fat32" = "$CONFIG_IMAGE_PARTITION_BOOT_TYPE" ]] ; then
			mkfs.fat -F 32 "${loop}p$boot_part" > /dev/null
		else
			mkfs.$CONFIG_IMAGE_PARTITION_BOOT_TYPE "${loop}p$boot_part" &> /dev/null
		fi
	fi

	if [[ $swap_size -gt 0 ]] ; then
		mkswap "${loop}p$swap_part" > /dev/null
	fi

	mkfs.$CONFIG_IMAGE_PARTITION_ROOT_TYPE "${loop}p$root_part" &> /dev/null

	# mount filesystm(s) under target
	mkdir -p "$DIBS_WORKSPACE/target"
	mount "${loop}p$root_part" "$DIBS_WORKSPACE/target"
	if [[ $boot_part -gt 0 ]] ; then
		mkdir -p "$DIBS_WORKSPACE/target/boot"
		mount "${loop}p$boot_part" "$DIBS_WORKSPACE/target/boot"
	fi

	# expand rootfs.tar
	dibs_untar

	# write fstab
	local f="$DIBS_WORKSPACE/target/etc/fstab"
	echo "# /etc/fstab: static file system information.
#
# Use 'blkid' to print the universally unique identifier for a
# device; this may be used with UUID= as a more robust way to name devices
# that works even if disks are added and removed. See fstab(5).
#
# <file system> <mount point>   <type>  <options>       <dump>  <pass>" > "$f"

	if [[ $boot_part -gt 0 ]] ; then
		local uuid=$(blkid -o value -s UUID "${loop}p$boot_part")
		if [[ "fat32" = "$CONFIG_IMAGE_PARTITION_BOOT_TYPE" ]] ; then
			echo "UUID=$uuid /boot fat umask=0077 0 1" >> "$f"
		else
			echo "UUID=$uuid /boot $CONFIG_IMAGE_PARTITION_BOOT_TYPE noatime 0 1" >> "$f"
		fi
	fi

	if [[ $swap_part -gt 0 ]] ; then
		local uuid=$(blkid -o value -s UUID "${loop}p$swap_part")
		echo "UUID=$uuid none swap sw 0 0" >> "$f"
	fi

	local uuid=$(blkid -o value -s UUID "${loop}p$root_part")
	echo "UUID=$uuid / $CONFIG_IMAGE_PARTITION_ROOT_TYPE noatime,errors=remount-ro 0 1" >> "$f"

	# flush
	sync

	# unmount filesystem(s)
	if [[ $boot_part -gt 0 ]] ; then
		umount "$DIBS_WORKSPACE/target/boot"
	fi
	umount "$DIBS_WORKSPACE/target"

	rmdir "$DIBS_WORKSPACE/target"

	# teardown loop device(s)
	losetup -d $loop
}

dibs_regen_help="regen: dibs regen
    Rebuilds all configuration dependent files such as multistrap.conf."
function dibs_regen()
{
	require_config

	local f="$DIBS_WORKSPACE/config/stage2.sh"
	echo "#!/bin/sh

set -e
export DEBIAN_FRONTEND=noninteractive DEBCONF_NONINTERACTIVE_SEEN=true
export LC_ALL=C LANGUAGE=C LANG=C
/var/lib/dpkg/info/dash.preinst install
mount proc -t proc /proc
rm -f /var/run/init.upgraded
dpkg --configure -a
umount /proc
rm -- \$0" > "$f"
	chmod 755 "$f"

	local extra_packages
	if [[ "$CONFIG_PROCESS_MANAGER" = "systemd" ]] ; then
		extra_packages="systemd systemd-sysv udev"
	elif [[ "$CONFIG_PROCESS_MANAGER" = "sysvinit" ]] ; then
		extra_packages="sysvinit-core udev"
	fi

	local f="$DIBS_WORKSPACE/config/multistrap.conf"
	echo "[General]
noauth=true
unpack=true
debootstrap=${CONFIG_DISTRO^} Security
aptsources=${CONFIG_DISTRO^} Security
cleanup=true
arch=$CONFIG_ARCH
directory=target
configscript=config/stage2.sh
" > "$f"
	if [[ "$CONFIG_DISTRO" = "debian" ]] ; then
		echo "[Debian]
packages=$CONFIG_PACKAGES $extra_packages
source=http://deb.debian.org/debian
keyring=debian-archive-keyring
components=main contrib non-free
suite=$CONFIG_RELEASE

[Security]
packages=
source=http://security.debian.org/
keyring=debian-archive-keyring
components=main contrib non-free
suite=$CONFIG_RELEASE/updates
" >> "$f"
	elif [[ "$CONFIG_DISTRO" = "ubuntu" ]] ; then
		echo "[Ubuntu]
packages=$CONFIG_PACKAGES $extra_packages" >> "$f"
		if [[ "$CONFIG_ARCH" != "amd64" ]] && [[ "$CONFIG_ARCH" != "i386" ]] ; then
			echo "source=http://ports.ubuntu.com/ubuntu-ports" >> "$f"
		else
			echo "source=http://archive.ubuntu.com/ubuntu" >> "$f"
		fi
		echo "keyring=ubuntu-keyring
components=main restricted universe multiverse
suite=$CONFIG_RELEASE

[Security]
packages=" >> "$f"
		if [[ "$CONFIG_ARCH" != "amd64" ]] && [[ "$CONFIG_ARCH" != "i386" ]] ; then
			echo "source=http://ports.ubuntu.com/ubuntu-ports" >> "$f"
		else
			echo "source=http://archive.ubuntu.com/ubuntu" >> "$f"
		fi
		echo "keyring=ubuntu-keyring
components=main restricted universe multiverse
suite=$CONFIG_RELEASE-security" >> "$f"
	fi
}

dibs_shell_help="shell: dibs shell
    Extracts the rootfs into target, starts a chroot shell and
    re-tars the directory when the chroot exits."
function dibs_shell()
{
	require_config

	dibs_untar
	install_static_qemu
	mount -t devtmpfs devtmpfs "$DIBS_TARGET/dev"
	mount -t tmpfs tmpfs "$DIBS_TARGET/tmp"
	mount -t proc proc "$DIBS_TARGET/proc"

	local f="$DIBS_TARGET/chroot.sh"
	echo "#!/bin/bash" > "$f"
	echo >> "$f"
	echo "export LC_ALL=C LANGUAGE=C LANG=C" >> "$f"
	echo "rm -- \$0" >> "$f"
	echo "exec /bin/bash" >> "$f"
	chmod 755 "$f"
	chroot "$DIBS_TARGET" /chroot.sh
	uninstall_static_qemu
	dibs_tar
}

dibs_tar_help="tar: dibs tar
    Makes a rootfs.tar from the contents of target."
function dibs_tar()
{
	require_target_dir
	unmount_target_subdirs

	echo "Storing target directory as rootfs.tar, please wait..."
	pushd "$DIBS_TARGET" > /dev/null
	tar --one-file-system -cf "$DIBS_WORKSPACE/rootfs.tar" .
	popd > /dev/null
	rm -rf --one-file-system "$DIBS_TARGET"
}

dibs_untar_help="untar: dibs untar
    Extracts a rootfs.tar file into target directory."
function dibs_untar()
{
	require_rootfs_tar

	echo "Expanding rootfs.tar to target, please wait..."

	export DIBS_TARGET="$DIBS_WORKSPACE/target"
	mkdir -p "$DIBS_TARGET"
	pushd "$DIBS_TARGET" > /dev/null
	tar -xf "$DIBS_WORKSPACE/rootfs.tar"
	popd > /dev/null
}

function dibs_usage()
{
	echo "Usage:
    board
    build
    config [board]
    help
	image
    regen
    shell
    tar
    untar
    usage"
	exit 1
}

command=$1
shift
if [[ -z "$command" ]] ; then
	dibs_usage "$@"
	exit 1
fi

declare -fF dibs_$command > /dev/null && dibs_$command "$@" || echo "Unknown command, see \"dibs help\"."
